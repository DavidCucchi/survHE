#' Plot survival curves for the models fitted using \code{fit.models}
#' 
#' Plots the results of model fit.
#' 
#' 
#' @param x Either a single object generated by the call to \code{fit.models}
#' or a list of such objects. 
#' @param mod the number specifying which model is to be plotted. By default,
#' if the object is 'survHE', plots all the models stored in there. But can 
#' be modified. 
#' @param ... Other possibilities are additional (mainly
#' graphical) options. These are: \code{xlab} = a string with the label for the
#' x-axis (default = "time") \code{ylab} = a string with the label for the
#' y-axis (default = "Survival") \code{lab.trt} = a (vector of) string(s)
#' indicating the labels associated with the strata defining the different
#' survival curves to plot. Default to the value used by the Kaplan Meier
#' estimate given in \code{fit.models} \code{cex.trt} = factor by which the
#' size of the font used to write the strata is resized (default = 0.8)
#' \code{n.risk} = logical. If TRUE (defaults) writes the number at risk at
#' different time points (as determined by the Kaplan Meier estimate)
#' \code{newdata} = a list (of lists) providing the values for the relevant
#' covariates If NULL, then will use the mean values for the covariates if at
#' least one is a continuous variable, or the combination of the categorical
#' covariates. \code{xlim} = a vector determining the limits for the x-axis
#' \code{colors} = a vector of characters defining the colours in which to plot
#' the different survival curves \code{labs} = a vector of characters defining
#' the names of the models fitted \code{add.km} = TRUE (whether to also add the
#' Kaplan Meier estimates of the data) \code{legend} = TRUE (whether to also 
#' add the legend to the graph)
#' @note Something will go here
#' @author Gianluca Baio
#' @seealso Something will go here
#' @references Something will go here
#' @keywords Parametric survival models
#' @examples
#' 
#' data(bc)
#' 
#' mle = fit.models(formula=Surv(recyrs,censrec)~group,data=bc,
#'     distr="exp",method="mle")
#' plot(mle)
#' 
plot_ggplot_survHE <- function(x,mod=NULL,add.km=TRUE,n.risk=FALSE) {
  # First checks the class of the input
  if(class(x)=="survHE") {
    # If x is a 'survHE' object, then there's only one object to deal with
    mods <- x$models
    totmodels <- length(mods)
    method <- rep(x$method,totmodels)
    aic <- unlist(x$model.fitting$aic)
    bic <- unlist(x$model.fitting$bic)
    dic <- unlist(x$model.fitting$dic)
    # Is this only one model?
    if(totmodels==1) {
      
    } else if (totmodels>1) {
      if(is.null(mod)) {
        # If 'add.km' is TRUE, then prepares to plot the KM curve
        if(add.km) {
          # Needs to hack the formula saved in the km object under $misc
          # otherwise ggsurvplot will complain
          x$misc$km$call$formula=as.formula(deparse(formula))
          kmplot <- survminer::ggsurvplot(fit=x$misc$km,data=x$misc$data,
                                          conf.int=TRUE,
                                          risk.table = n.risk,        # Add risk table?
                                          risk.table.col = "strata",
                                          palette = c("#E7B800", "#2E9FDF"),
                                          legend.labs = c("Controls", "Treated"),
                                          risk.table.height = 0.25, # Useful to change when you have multiple groups
                                          ggtheme = ggplot2::theme_bw()
          ) 
        }
        # Now needs to add the survival curves for the models (with no interval estimate in this case)
        
        
        mod=length(mods)
        
      } else {
        mod=mod
      }
      
    }
    
    if(totmodels>1){
      if (!is.null(exArgs$mod)) {which.model <- exArgs$mod} else {which.model <- 1:length(mods)}
      mods <- lapply(which.model,function(i) mods[[i]])
      method <- method[which.model]
      aic <- aic[which.model]
      bic <- bic[which.model]
      dic <- dic[which.model]
    }
  } else if(class(x)=="list") {
    # If x is a list then need to check all the elements are in fact
    # 'survHE' objects and then process then one by one, adding to the 
    # layered graph
    
  }
}